<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  /* --- Âü∫Êú¨„Çπ„Çø„Ç§„É´ --- */
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: #222;
    overflow: hidden; /* „Çπ„ÇØ„É≠„Éº„É´ÂÆåÂÖ®Á¶ÅÊ≠¢ */
  }

  body { 
    color: white; 
    font-family: 'Courier New', sans-serif; 
    display: flex; 
    flex-direction: column;
    justify-content: center; 
    align-items: center; 
    position: fixed; /* ÁîªÈù¢Âõ∫ÂÆö */
    top: 0; left: 0; right: 0; bottom: 0;
    overscroll-behavior: none;
    touch-action: none; /* „Éî„É≥„ÉÅ„Ç∫„Éº„É†Á≠âÁ¶ÅÊ≠¢ */
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
   
  /* CanvasË®≠ÂÆö */
  canvas { 
      background-color: #87CEEB; 
      border: 2px solid #fff; 
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      /* „Éá„Éï„Ç©„É´„ÉàPCÁî® */
      width: 800px;
      height: 400px;
  }
   
  /* ‚òÖ‰øÆÊ≠£: „Çπ„Éû„ÉõÁ∏¶ÊåÅ„Å°ÊôÇ„ÅÆCanvasÊúÄÈÅ©Âåñ */
  /* ÁîªÈù¢ÂπÖ„Å´Âêà„Çè„Åõ„Å¶Á∏ÆÂ∞èË°®Á§∫„Åó„ÄÅÊ®™ÂπÖ„ÇíÁ®º„Åê */
  @media (max-width: 800px) {
      canvas {
          width: 100vw;        /* „Çπ„Éû„Éõ„ÅÆÊ®™ÂπÖ„ÅÑ„Å£„Å±„ÅÑ„Å´ */
          height: auto;        /* „Ç¢„Çπ„Éö„ÇØ„ÉàÊØîÁ∂≠ÊåÅ */
          max-height: 60vh;    /* Á∏¶Èï∑„Å´„Å™„Çä„Åô„Åé„Å™„ÅÑ„Çà„ÅÜ„Å´Âà∂Èôê */
          object-fit: contain;
      }
  }

  /* --- UI„É¨„Ç§„É§„Éº --- */
  #ui-layer { 
      position: absolute; 
      top: 10px; left: 10px; 
      font-size: 20px; font-weight: bold; 
      color: black; 
      pointer-events: none; 
      text-shadow: 1px 1px 0 #fff; 
      z-index: 5; 
      background: rgba(255,255,255,0.3);
      padding: 5px;
      border-radius: 5px;
  }

  #hearts { color: red; font-size: 24px; }
  #status-msg { font-size: 16px; margin-top: 5px; }

  /* --- „Çø„Ç§„Éà„É´ÁîªÈù¢ --- */
  #title-screen {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.4); z-index: 10;
    pointer-events: none;
  }
   
  .title-img { max-width: 40%; height: auto; margin-bottom: 20px; opacity: 0; }
   
  .start-text { font-size: 30px; color: white; text-shadow: 2px 2px #000; font-weight: bold; opacity: 0; }
   
  @keyframes slideUpFade { 0% { opacity: 0; transform: translateY(100px); } 100% { opacity: 1; transform: translateY(0); } }
  @keyframes blinkFade { 0% { opacity: 0; } 100% { opacity: 1; } }
  @keyframes blinkRed { 0% { color: red; } 50% { color: white; } 100% { color: red; } }

  /* --- „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Éª„É©„É≥„Ç≠„É≥„Ç∞ÁîªÈù¢ --- */
  #overlay { 
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: rgba(0, 0, 0, 0.9); border: 2px solid white; border-radius: 10px;
    padding: 20px; text-align: center; color: white; display: none; width: 90%; max-width: 400px;
    z-index: 200; 
  }

  h2 { margin-top: 0; color: yellow; text-shadow: 2px 2px #f00; font-size: 24px; }
   
  table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px; }
  th, td { border-bottom: 1px solid #555; padding: 4px; text-align: left; }
  th { color: #aaa; }
  .rank-col { width: 30px; text-align: center; }
  .score-col { text-align: right; color: #0f0; }
   
  #input-section { margin-bottom: 15px; display: none; }
  input[type="text"] { padding: 5px; font-size: 16px; width: 60%; text-align: center; user-select: text; -webkit-user-select: text; }
  button { padding: 5px 15px; font-size: 16px; cursor: pointer; background: #f00; color: white; border: none; font-weight: bold; margin-left: 5px; }
   
  #loading-msg { display: none; color: yellow; font-weight: bold; margin-top: 10px; animation: blink 1s infinite; }
  .restart-msg { margin-top: 15px; font-size: 14px; color: #ccc; }

  #auto-restart-msg {
      display: none; color: #00d2ff; margin-top: 15px; font-size: 16px; font-weight: bold; animation: blink 1s infinite;
  }

  /* --- Á∏¶ÁîªÈù¢Ë≠¶Âëä (PC„Åß„ÅØÈùûË°®Á§∫„ÄÅ„Çπ„Éû„Éõ„ÅßÊ®™„ÅÆ„Å®„ÅçË°®Á§∫) --- */
  #orientation-warning {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); z-index: 9999;
      flex-direction: column; justify-content: center; align-items: center;
      text-align: center; color: white;
  }
  .rotate-icon { font-size: 60px; margin-bottom: 20px; }
  .rotate-msg { font-size: 24px; font-weight: bold; animation: blinkRed 1s infinite; padding: 20px; }

  /* --- „É¢„Éê„Ç§„É´„Ç≥„É≥„Éà„É≠„Éº„É©„Éº --- */
  #mobile-controls {
    display: none; 
    position: absolute; 
    bottom: 0; left: 0; width: 100%; height: 180px;
    z-index: 100; pointer-events: none; 
    justify-content: space-between; 
    padding: 10px 20px; 
    box-sizing: border-box; 
    align-items: center; /* ‰∏ä‰∏ã‰∏≠Â§Æ */
  }

  /* „Çπ„Éû„Éõ„Éª„Çø„Éñ„É¨„ÉÉ„ÉàÁî®Ë°®Á§∫Ë®≠ÂÆö */
  @media (hover: none) and (pointer: coarse) {
    #mobile-controls { display: flex; }
    .restart-msg { display: none; }
  }

  .joystick-area {
      pointer-events: auto; width: 120px; height: 120px; 
      background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; touch-action: none;
      position: relative;
  }
  .joystick-knob {
      width: 50px; height: 50px; background: rgba(0, 210, 255, 0.8); border-radius: 50%; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px rgba(0, 210, 255, 0.5); pointer-events: none;
  }

  .action-btn-area { pointer-events: auto; }
  .touch-btn {
    width: 90px; height: 90px; border-radius: 50%; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.6);
    color: white; font-size: 40px; display: flex; justify-content: center; align-items: center; touch-action: manipulation;
    user-select: none; -webkit-user-select: none; cursor: pointer; text-shadow: 1px 1px 2px black;
  }
  .touch-btn:active { background: rgba(255, 255, 255, 0.5); }

</style>
</head>
<body>

<!-- Ê®™ÁîªÈù¢Ë≠¶ÂëäÔºàÁ∏¶„Å´„Åó„Å¶„Å≠Ôºâ -->
<div id="orientation-warning">
    <div class="rotate-icon">üì±‚ü≤</div>
    <div class="rotate-msg">Please Rotate to Portrait<br>ÁîªÈù¢„ÇíÁ∏¶„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
    <div style="margin-top:20px; color:#aaa;">Game Paused</div>
</div>

<div id="ui-layer">
    Score: <span id="score">0</span> | Level: <span id="level">1</span><br>
    Life: <span id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
    <div id="status-msg"></div>
</div>

<!-- „Ç≤„Éº„É†„Ç≠„É£„É≥„Éê„Çπ -->
<canvas id="gameCanvas" width="800" height="400"></canvas>

<div id="title-screen">
    <img id="title-img" class="title-img" src="https://raw.githubusercontent.com/m-fukuda-blip/game/main/game_title.png" alt="GAME TITLE">
    <div id="start-text" class="start-text">GAME START!</div>
</div>

<div id="overlay">
    <h2 id="overlay-title">GAME OVER</h2>
    <div id="final-score-display" style="font-size: 24px; margin-bottom: 15px;"></div>
    <div id="input-section">
        <p style="color: cyan;">üéâ NEW RECORD! üéâ</p>
        <input type="text" id="player-name" placeholder="Enter Name" maxlength="8">
        <button id="submit-btn" onclick="submitScore()">Save</button>
        <div id="loading-msg">‚è≥ Saving...</div>
    </div>
    <div id="ranking-section">
        <div id="rank-loading" style="color:#aaa; display:none;">Loading Ranking...</div>
        <table><thead><tr><th class="rank-col">#</th><th>Name</th><th class="score-col">Score</th></tr></thead><tbody id="ranking-body"></tbody></table>
    </div>
    <div class="restart-msg">Press 'R' to Restart</div>
    <div id="auto-restart-msg"></div>
</div>

<div id="mobile-controls">
    <div id="joystick-area" class="joystick-area">
        <div id="joystick-knob" class="joystick-knob"></div>
    </div>
    <div class="action-btn-area">
        <div id="btn-jump" class="touch-btn" style="background: rgba(255, 200, 0, 0.4);">‚ñ≤</div>
    </div>
</div>

<script>
  document.addEventListener('contextmenu', event => event.preventDefault());
  // Prevent pull-to-refresh on mobile
  document.body.addEventListener('touchmove', function(e) { if(e.cancelable) e.preventDefault(); }, { passive: false });

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
   
  // „Çπ„Éû„ÉõÂà§ÂÆö
  const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.innerWidth < 800);
  let isPaused = false;
  const orientationWarning = document.getElementById('orientation-warning');

  // ‚òÖ‰øÆÊ≠£: ÁîªÈù¢Âêë„Åç„ÉÅ„Çß„ÉÉ„ÇØ & Canvas„Çµ„Ç§„Ç∫Ë®≠ÂÆö (Á∏¶ÁîªÈù¢ÊúÄÈÅ©Âåñ)
  function checkOrientationAndResize() {
      if (isMobile) {
          // Ê®™Èï∑„ÅÆÂ†¥Âêà -> Ë≠¶Âëä„ÇíÂá∫„Åó„Å¶„Éù„Éº„Ç∫
          if (window.innerWidth > window.innerHeight) {
              isPaused = true;
              orientationWarning.style.display = 'flex';
          } else {
              // Á∏¶Èï∑„ÅÆÂ†¥Âêà -> „Ç≤„Éº„É†ÂÜçÈñã
              isPaused = false;
              orientationWarning.style.display = 'none';
               
              // ‚òÖÈáçË¶Å: CanvasËß£ÂÉèÂ∫¶„ÅØÂ§ß„Åç„Åè(640px)Á¢∫‰øù„Åó„ÄÅCSS„ÅßÁ∏ÆÂ∞èË°®Á§∫„Åô„Çã„ÄÇ
              canvas.width = 640; 
              canvas.height = 400; 
          }
      } else {
          // PC
          canvas.width = 800;
          canvas.height = 400;
      }
  }
   
  // Ë™≠„ÅøËæº„ÅøÊôÇ„Å®„É™„Çµ„Ç§„Ç∫ÊôÇ„Å´„ÉÅ„Çß„ÉÉ„ÇØ
  window.addEventListener('resize', checkOrientationAndResize);
  checkOrientationAndResize();

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const heartsEl = document.getElementById('hearts');
  const statusMsgEl = document.getElementById('status-msg');
  const overlay = document.getElementById('overlay');
  const inputSection = document.getElementById('input-section');
  const rankingBody = document.getElementById('ranking-body');
  const finalScoreDisplay = document.getElementById('final-score-display');
  const nameInput = document.getElementById('player-name');
  const submitBtn = document.getElementById('submit-btn');
  const loadingMsg = document.getElementById('loading-msg');
  const rankLoading = document.getElementById('rank-loading');
  const autoRestartMsg = document.getElementById('auto-restart-msg');
  const titleScreen = document.getElementById('title-screen');
  const titleImg = document.getElementById('title-img');
  const startText = document.getElementById('start-text');

  // „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ
  const joystickArea = document.getElementById('joystick-area');
  const joystickKnob = document.getElementById('joystick-knob');
  let stickTouchId = null;

  if (joystickArea) {
      const maxRadius = 40; const center = { x: 60, y: 60 }; 
      joystickArea.addEventListener('touchstart', (e) => {
          e.preventDefault(); const touch = e.changedTouches[0]; stickTouchId = touch.identifier; startBGM(); updateStick(touch);
      }, {passive: false});
      joystickArea.addEventListener('touchmove', (e) => {
          e.preventDefault();
          for (let i = 0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === stickTouchId) { updateStick(e.changedTouches[i]); break; } }
      }, {passive: false});
      const endStick = (e) => {
          e.preventDefault();
          for (let i = 0; i < e.changedTouches.length; i++) {
              if (e.changedTouches[i].identifier === stickTouchId) {
                  stickTouchId = null; joystickKnob.style.transform = `translate(-50%, -50%) translate(0px, 0px)`;
                  keys.left = false; keys.right = false; keys.down = false; break;
              }
          }
      };
      joystickArea.addEventListener('touchend', endStick); joystickArea.addEventListener('touchcancel', endStick);

      function updateStick(touch) {
          const rect = joystickArea.getBoundingClientRect();
          let x = touch.clientX - rect.left - center.x; let y = touch.clientY - rect.top - center.y;
          const distance = Math.sqrt(x*x + y*y);
          if (distance > maxRadius) { const angle = Math.atan2(y, x); x = Math.cos(angle) * maxRadius; y = Math.sin(angle) * maxRadius; }
          joystickKnob.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
          keys.left = false; keys.right = false; keys.down = false;
          if (distance > 10) { if (Math.abs(x) > Math.abs(y)) { if (x > 0) keys.right = true; else keys.left = true; } else { if (y > 0) keys.down = true; } }
      }
  }
   
  const btnJump = document.getElementById('btn-jump');
  if(btnJump) { btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); doJump(); }); }

  // ... („Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØÂ§âÊï∞) ...
  let screenShake = { x: 0, y: 0, duration: 0, intensity: 0 };
  function addShake(intensity, duration) { screenShake.intensity = intensity; screenShake.duration = duration; }
  function updateShake() { if (screenShake.duration > 0) { screenShake.x = (Math.random() - 0.5) * screenShake.intensity; screenShake.y = (Math.random() - 0.5) * screenShake.intensity; screenShake.duration--; } else { screenShake.x = 0; screenShake.y = 0; } }

  let particles = [];
  function spawnParticles(x, y, color, count = 8) { for (let i = 0; i < count; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 30 + Math.random() * 20, size: 4 + Math.random() * 4, color: color }); } }
  function updateAndDrawParticles() { for (let i = 0; i < particles.length; i++) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--; p.size *= 0.95; if (p.life <= 0 || p.size < 0.5) { particles.splice(i, 1); i--; } } }

  let audioCtx, isBgmPlaying = false, bgmTimeout = null, activeOscillators = [];
  const BASE_BPM = 130, BASE_BEAT_TIME = 60 / BASE_BPM;
  const melody = [5,5,6,5,3,-1,3,5, 5,5,6,5,3,-1,3,2, 5,5,6,5,8,8,7,6, 6,5,3,3,-1,5,-1,-1];
  const scaleToFreq = (num) => { if(num < 0) return null; const scale = [261.63,293.66,329.63,349.23,392.00,440.00,493.88,523.25]; return scale[num-1]; };

  function playNoiseForBGM(time, duration, volume){ if (audioCtx.state === 'suspended') audioCtx.resume(); const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate); const data = buffer.getChannelData(0); for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1); const noise = audioCtx.createBufferSource(); noise.buffer = buffer; const gain = audioCtx.createGain(); gain.gain.setValueAtTime(volume, time); gain.gain.exponentialRampToValueAtTime(0.01, time + duration); noise.connect(gain).connect(audioCtx.destination); noise.start(time); activeOscillators.push(noise); }
  function playNoteForBGM(freq, time, duration){ if (audioCtx.state === 'suspended') audioCtx.resume(); const osc = audioCtx.createOscillator(); osc.type = "square"; osc.frequency.value = freq; const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.15, time); gain.gain.exponentialRampToValueAtTime(0.01, time + duration); osc.connect(gain).connect(audioCtx.destination); osc.start(time); osc.stop(time + duration); activeOscillators.push(osc); }
  function getCurrentBeatTime() { let multiplier = 1.0 + Math.min(score, 10000) / 10000 * 3.0; return BASE_BEAT_TIME / multiplier; }
  function playBGMLoop(){ if (!isBgmPlaying) return; const start = audioCtx.currentTime; const currentBeat = getCurrentBeatTime(); melody.forEach((note,i)=>{ const t = start + i * currentBeat; if(note > 0) playNoteForBGM(scaleToFreq(note), t, currentBeat); else playNoiseForBGM(t, 0.03, 0.1); }); bgmTimeout = setTimeout(playBGMLoop, melody.length * currentBeat * 1000); }
  function startBGM() { if (isBgmPlaying) return; isBgmPlaying = true; if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); playBGMLoop(); }
  function stopBGM() { isBgmPlaying = false; if (bgmTimeout) clearTimeout(bgmTimeout); activeOscillators.forEach(node => { try { node.stop(); } catch(e) {} }); activeOscillators = []; }
  function playGameOverSound() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.type = 'sawtooth'; osc.connect(gain); gain.connect(audioCtx.destination); const now = audioCtx.currentTime; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.8); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8); osc.start(now); osc.stop(now + 0.8); }

  function loadResized(src, w, h) { const wrapper = { img: null, ready: false, error: false }; const img = new Image(); img.crossOrigin = "Anonymous"; img.src = src; img.onload = () => { const offCanvas = document.createElement('canvas'); offCanvas.width = w; offCanvas.height = h; const offCtx = offCanvas.getContext('2d'); offCtx.drawImage(img, 0, 0, w, h); wrapper.img = offCanvas; wrapper.ready = true; }; img.onerror = () => { wrapper.error = true; }; return wrapper; }

  const P_W = 60, P_H = 60; 
  const playerAnim = { idle: [], run: [], jump: [], dead: null, squat: null };
  for(let i=1; i<=3; i++) playerAnim.idle.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/Taiki0${i}.png`, P_W, P_H));
  for(let i=1; i<=3; i++) playerAnim.run.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/Run0${i}.png`, P_W, P_H));
  for(let i=1; i<=3; i++) playerAnim.jump.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/Jump0${i}.png`, P_W, P_H));
  playerAnim.dead = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/Dead.png", P_W, P_H);
  playerAnim.squat = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/squat.png", P_W, P_H);

  const enemyAnim = [], enemy2Anim = [];
  for(let i=1; i<=2; i++) { enemyAnim.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/EnemyAction0${i}.png`, 52, 52)); }
  for(let i=1; i<=2; i++) { enemy2Anim.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/Enemy2Action0${i}.png`, 52, 52)); }
  const itemImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/coin.png", 45, 45);
  const capsuleImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/capsule.png", 45, 45);
  const mutekiImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/muteki.png", 45, 45);
  const jyamaImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/jyama.png", 45, 45);
  const crownImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/crown.png", 45, 45);
  const itemEffectAnim = [];
  for(let i=1; i<=3; i++) itemEffectAnim.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/ItemAction0${i}.png`, 45, 45));
  const cloudImgWrappers = [];
  for(let i=1; i<=4; i++) cloudImgWrappers.push(loadResized(`https://raw.githubusercontent.com/m-fukuda-blip/game/main/cloud${i}.png`, 170, 120)); 
  const mountainImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/mountains.png", 3000, 200);
  const buildingImgWrapper = loadResized("https://raw.githubusercontent.com/m-fukuda-blip/game/main/buildings.png", 3000, 200);

  const GRAVITY = 0.6, FRICTION = 0.8, BASE_GROUND_Y = 360;  
  let score = 0, level = 1, gameSpeed = 1.0, hp = 3, gameOver = false, isTitle = true; 
  let frameCount = 0, nextEnemySpawn = 0, nextItemSpawn = 0;
  let facingRight = true, isInvincible = false, invincibleTimer = 0, terrainSegments = [];
  let superMode = false, superModeTimer = 0, slowMode = false, slowModeTimer = 0;
  // ‚òÖÁéãÂÜ†„Éú„Éº„Éä„ÇπÁî®„ÅÆÂ§âÊï∞ËøΩÂä†
  let crownBonusMode = false, crownBonusTimer = 0;
  let floatingTexts = [], autoRestartTimer = null;
  let cameraX = 0, lastGeneratedX = 0;
  let platforms = [], checkpoints = [], nextCheckpointDist = 800 * 10; 

  const player = { 
      x: 200, y: 0, width: 60, height: 60, speed: 7, dx: 0, dy: 0, 
      jumping: false, jumpCount: 0, maxJump: 2,
      state: 'idle', animIndex: 0, animTimer: 0, animSpeedIdle: 15, animSpeedRun: 8, idlePingPong: 1, combo: 0 
  };
   
  let enemies = [], items = [], clouds = [];
  // Debug key states added (k, o)
  const keys = { right: false, left: false, up: false, down: false, k: false, o: false }; 

  // ‚òÖÈáçË¶Å: PythonÂÅ¥„Åß„Åì„Åì„ÅåÁΩÆÊèõ„Åï„Çå„Çã
  const API_URL = "{GAS_API_URL}";
  
  let globalRankings = [];

  async function fetchRankings() { try { const response = await fetch(API_URL); return await response.json(); } catch (e) { return []; } }
  async function sendScore(name, score) { try { await fetch(API_URL, { method: 'POST', body: JSON.stringify({ name: name, score: score }) }); } catch (e) {} }
  fetchRankings().then(data => { globalRankings = data; });
  function checkRankIn(currentScore) { if (globalRankings.length < 10) return true; return currentScore > globalRankings[globalRankings.length - 1].score; }
  function startAutoRestartCountdown() {
      let count = 5; autoRestartMsg.style.display = 'block'; autoRestartMsg.innerText = `Restarting in ${count}...`;
      if (autoRestartTimer) clearInterval(autoRestartTimer);
      autoRestartTimer = setInterval(() => { count--; if (count > 0) autoRestartMsg.innerText = `Restarting in ${count}...`; else { clearInterval(autoRestartTimer); resetGame(); } }, 1000);
  }
  async function submitScore() {
    const name = nameInput.value.trim() || "NO NAME"; nameInput.disabled = true; submitBtn.disabled = true; loadingMsg.style.display = 'block';
    await sendScore(name, score); globalRankings = await fetchRankings();
    loadingMsg.style.display = 'none'; nameInput.disabled = false; submitBtn.disabled = false; inputSection.style.display = 'none'; showRankingTable(globalRankings);
    if (isMobile) startAutoRestartCountdown();
  }
  function showRankingTable(rankings) {
    if (!rankings) rankings = globalRankings; rankingBody.innerHTML = "";
    for (let i = 0; i < 10; i++) {
        let r = rankings[i]; let row = document.createElement('tr');
        if (r) row.innerHTML = `<td class="rank-col">${i + 1}</td><td style="${r.score === score && r.name === nameInput.value ? "color: yellow; font-weight:bold;" : ""}">${r.name}</td><td class="score-col">${r.score}</td>`;
        else row.innerHTML = `<td class="rank-col">${i + 1}</td><td>---</td><td class="score-col">0</td>`;
        rankingBody.appendChild(row);
    }
  }
  function handleGameOver() {
    gameOver = true; player.state = 'dead'; stopBGM(); playGameOverSound(); addShake(15, 20); 
    overlay.style.display = 'block'; finalScoreDisplay.innerText = "Final Score: " + score;
    nameInput.value = ""; rankingBody.innerHTML = ""; rankLoading.style.display = "block";
    fetchRankings().then(data => {
        globalRankings = data; rankLoading.style.display = "none"; showRankingTable(globalRankings);
        if (score > 0 && checkRankIn(score)) { inputSection.style.display = 'block'; nameInput.focus(); } 
        else { inputSection.style.display = 'none'; if (isMobile) startAutoRestartCountdown(); }
    });
  }
  function playSound(type) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.connect(gain); gain.connect(audioCtx.destination); const now = audioCtx.currentTime;
    if (type === 'jump') { osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(300, now + 0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); } 
    else if (type === 'coin') { osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.setValueAtTime(1600, now + 0.05); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2); osc.start(now); osc.stop(now + 0.2); } 
    else if (type === 'hit') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(50, now + 0.3); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); osc.start(now); osc.stop(now + 0.3); } 
    else if (type === 'heal') { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.2); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); } 
    else if (type === 'powerup') { osc.type = 'square'; osc.frequency.setValueAtTime(440, now); osc.frequency.setValueAtTime(880, now + 0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5); } 
    else if (type === 'bad') { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(150, now + 0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); }
    else if (type === 'gate') { osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(1200, now + 0.3); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.4); osc.start(now); osc.stop(now + 0.4); }
  }
  function doJump() {
      if (!gameOver && !isTitle) {
          if (!player.jumping || player.jumpCount < player.maxJump) {
              player.jumping = true; player.dy = -12; player.jumpCount++; playSound('jump'); startBGM();
          }
      }
  }

  document.addEventListener('keydown', (e) => {
    if (document.activeElement === nameInput) { if (e.key === 'Enter' && !submitBtn.disabled) submitScore(); return; }
    if (player.state === 'dead' && e.code !== 'KeyR') return;
    if (e.code === 'KeyF') { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else if (document.exitFullscreen) document.exitFullscreen(); }
    if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyR', 'KeyF'].includes(e.code)) { e.preventDefault(); }
    if (e.code === 'KeyD') { keys.right = true; facingRight = true; startBGM(); } 
    if (e.code === 'KeyA') { keys.left = true; facingRight = false; startBGM(); } 
    if (e.code === 'KeyS') { keys.down = true; startBGM(); } 
    if (e.code === 'KeyW') { doJump(); }
    if (e.code === 'KeyR' && gameOver) resetGame();
    // Debug keys
    if (e.code === 'KeyK') keys.k = true;
    if (e.code === 'KeyO') keys.o = true;
  });
  document.addEventListener('keyup', (e) => { 
      if (e.code === 'KeyD') keys.right = false; 
      if (e.code === 'KeyA') keys.left = false; 
      if (e.code === 'KeyS') keys.down = false; 
      if (e.code === 'KeyK') keys.k = false;
      if (e.code === 'KeyO') keys.o = false;
  });

  function updateTerrain() {
      const deleteThreshold = cameraX - 200;
      for (let i = 0; i < terrainSegments.length; i++) { if (terrainSegments[i].x + terrainSegments[i].width < deleteThreshold) { terrainSegments.splice(i, 1); i--; } }
      for (let i = 0; i < platforms.length; i++) { if (platforms[i].x + platforms[i].width < deleteThreshold) { platforms.splice(i, 1); i--; } }
      for (let i = 0; i < checkpoints.length; i++) { if (checkpoints[i].x + 100 < deleteThreshold) { checkpoints.splice(i, 1); i--; } }
       
      // ‚òÖ‰øÆÊ≠£: ÂÖàË™≠„ÅøÁîüÊàêË∑ùÈõ¢„ÇíÂ∫É„Åí„Çã
      const generateThreshold = cameraX + canvas.width + 800; 
      while (lastGeneratedX < generateThreshold) { generateNextSegment(); }
      if (lastGeneratedX > nextCheckpointDist) { checkpoints.push({ x: nextCheckpointDist, passed: false }); nextCheckpointDist += 800 * 10; }
  }

  function generateNextSegment() {
      if (terrainSegments.length === 0) { terrainSegments.push({ x: 0, width: 800, topY: BASE_GROUND_Y, level: 0 }); lastGeneratedX = 800; return; }
      let prevSeg = terrainSegments[terrainSegments.length - 1];
      let gapWidth = 0;
      if (Math.random() < 0.25 && prevSeg.width > 100) gapWidth = Math.random() * 100 + 80; 
      let newX = lastGeneratedX + gapWidth; let width = Math.random() * 200 + 150; 
      const SEG_HEIGHTS = [BASE_GROUND_Y, BASE_GROUND_Y - 50, BASE_GROUND_Y - 100];
      let prevLevel = prevSeg.level !== undefined ? prevSeg.level : 0;
      let delta = Math.floor(Math.random() * 3) - 1; 
      let newLevel = Math.min(2, Math.max(0, prevLevel + delta));
      let topY = SEG_HEIGHTS[newLevel];
      terrainSegments.push({ x: newX, width: width, topY: topY, level: newLevel });
      lastGeneratedX = newX + width;

      if (Math.random() < 0.3) {
          let pW = player.width * (3 + Math.random() * 2); let pX = newX + Math.random() * (width - pW); let pY = topY - 100 - Math.random() * 80; 
          if (pY < 100) pY = 100;
          platforms.push({ x: pX, y: pY, width: pW, height: 20 });
          if (Math.random() < 0.5) spawnEnemyOnTerrain(pX, pW, pY);
      }
      if (gapWidth === 0 && width > 100) { if (Math.random() < 1.0) spawnEnemyOnTerrain(newX, width, topY); if (Math.random() < 0.8) spawnItemOnTerrain(newX, width, topY); }
  }
   
  function spawnEnemyOnTerrain(tx, tw, ty) {
      let type = Math.random() < 0.5 ? 'ground' : 'flying'; let speedBase = 2 + level * 0.05; let ex = tx + Math.random() * (tw - 60) + 30; let ey = ty - 52; 
      if (type === 'flying') ey = ty - 100 - Math.random() * 100; if (score >= 2000 && Math.random() < 0.3) { type = 'hard'; speedBase += 2; }
      enemies.push({ x: ex, y: ey, width: 52, height: 52, dx: -speedBase, dy: 0, type: type, angle: 0, animIndex: 0, animTimer: 0 });
  }

  function spawnItemOnTerrain(tx, tw, ty) {
      const r = Math.random(); let type = 'coin';
      // ‚òÖÁéãÂÜ†„ÅÆÂá∫ÁèæÊù°‰ª∂: „Çπ„Ç≥„Ç¢10000‰ª•‰∏ä„Åã„Å§‰ΩéÁ¢∫Áéá(1%)
      if (score >= 10000 && r < 0.01) type = 'crown';
      else if (r < 0.005) type = 'star'; 
      else if (r < 0.035) type = 'trap'; 
      else if (r < 0.045) type = 'heal'; 
      else type = 'coin';

      let ix = tx + Math.random() * (tw - 50) + 25; 
      let iy = ty - 45 - Math.random() * 100;
      
      // ‚òÖÁéãÂÜ†„ÅØÈ´ò„ÅÑ‰ΩçÁΩÆ„Å´Âá∫Áèæ„Åï„Åõ„Çã
      if (type === 'crown') {
          iy = ty - 150 - Math.random() * 50; 
      }
      
      items.push({ x: ix, y: iy, width: 45, height: 45, dx: 0, isCollected: false, animIndex: 0, animTimer: 0, type: type }); 
  }
   
  function getGroundYUnderPlayer() {
    let groundY = null; let centerX = player.x + player.width / 2;
    for (let seg of terrainSegments) { if (centerX > seg.x && centerX < seg.x + seg.width) { if (groundY === null || seg.topY < groundY) groundY = seg.topY; } }
    for (let p of platforms) { if (centerX > p.x && centerX < p.x + p.width) { if (player.y + player.height <= p.y + 20) { if (groundY === null || p.y < groundY) groundY = p.y; } } }
    return groundY;
  }
  function getGroundYAtX(x) {
    let groundY = null; for (let seg of terrainSegments) { if (x >= seg.x && x <= seg.x + seg.width) { if (groundY === null || seg.topY < groundY) groundY = seg.topY; } } return groundY;
  }

  function initClouds() { clouds = []; for(let i=0; i<8; i++) { clouds.push({ x: Math.random() * 1200, y: Math.random() * 200, speed: Math.random() * 0.3 + 0.1, imgIndex: Math.floor(Math.random() * 4) }); } }
  function updateClouds() {
    for(let c of clouds) { c.x -= c.speed; if(c.x < 0.2 * cameraX - 200) { c.x = 0.2 * cameraX + canvas.width + 200 + Math.random() * 200; c.y = Math.random() * 150; c.imgIndex = Math.floor(Math.random() * 4); } }
  }
  function updateLevel() { const newLevel = Math.floor(score / 500) + 1; if (newLevel > level) { level = newLevel; gameSpeed = 1.0 + (level * 0.05); levelEl.innerText = level; if(hp < 3) { hp++; updateHearts(); } } }
  function updateHearts() { let h = ""; for(let i=0; i<hp; i++) h += "‚ù§Ô∏è"; heartsEl.innerText = h; }

  function resetGame() {
    if (autoRestartTimer) clearInterval(autoRestartTimer); autoRestartMsg.style.display = 'none';
    player.x = 200; player.y = 0; player.dx = 0; player.dy = 0; cameraX = 0; lastGeneratedX = 0;
    player.state = 'idle'; player.animIndex = 0; player.animTimer = 0; player.idlePingPong = 1; player.combo = 0; player.jumpCount = 0;
    score = 0; level = 1; gameSpeed = 1.0; hp = 3;
    enemies = []; items = []; floatingTexts = []; particles = []; terrainSegments = []; platforms = []; checkpoints = []; nextCheckpointDist = 800 * 10;
    gameOver = false; frameCount = 0; isInvincible = false; nextEnemySpawn = 0; nextItemSpawn = 0;
    scoreEl.innerText = score; levelEl.innerText = level;
    superMode = false; superModeTimer = 0; slowMode = false; slowModeTimer = 0; statusMsgEl.innerText = "";
    // ‚òÖÁéãÂÜ†„Éú„Éº„Éä„ÇπÂàùÊúüÂåñ
    crownBonusMode = false; crownBonusTimer = 0;

    isTitle = true; titleScreen.style.display = 'flex';
    titleImg.style.animation = 'none'; void titleImg.offsetWidth; titleImg.style.animation = 'slideUpFade 2s forwards';
    startText.style.opacity = '0'; startText.style.animation = 'none';
    setTimeout(() => { startText.style.animation = 'blinkFade 0.5s forwards'; setTimeout(() => { titleScreen.style.display = 'none'; isTitle = false; }, 1000); }, 2000);

    updateHearts(); initClouds(); checkOrientationAndResize(); updateTerrain(); 
    const startGround = getGroundYUnderPlayer(); const gY = startGround !== null ? startGround : BASE_GROUND_Y; 
    player.y = gY - player.height; overlay.style.display = 'none';
  }

  function updatePlayerAnimation() {
    const prevState = player.state;
    if (hp <= 0) player.state = 'dead'; else if (player.jumping) player.state = 'jump'; else if (keys.down) player.state = 'squat'; else if (keys.right || keys.left) player.state = 'run'; else player.state = 'idle';
    if (player.state !== prevState) { player.animTimer = 0; player.animIndex = 0; player.idlePingPong = 1; }
    player.animTimer++;
    switch (player.state) {
        case 'idle': if (player.animTimer > player.animSpeedIdle) { player.animIndex += player.idlePingPong; if (player.animIndex >= 2) player.idlePingPong = -1; if (player.animIndex <= 0) player.idlePingPong = 1; player.animTimer = 0; } break;
        case 'run': if (player.animTimer > player.animSpeedRun) { player.animIndex = (player.animIndex + 1) % 3; player.animTimer = 0; } break;
        case 'jump': if (player.dy < -5) player.animIndex = 0; else if (player.dy < 0) player.animIndex = 1; else if (player.dy < 5) player.animIndex = 2; else player.animIndex = 1; break;
        case 'squat': player.animIndex = 0; break;
        case 'dead': player.animIndex = 0; break;
    }
  }

  function update() {
    if (isPaused) return;
    if (gameOver && player.state !== 'dead') return; if (player.state === 'dead') return;
    if (isTitle) { updateClouds(); return; }

    updateShake(); frameCount++; updateClouds();
    if (isInvincible) { invincibleTimer--; if (invincibleTimer <= 0) isInvincible = false; }
     
    // Debug Command Check (K + O)
    if (keys.k && keys.o && score < 10000) {
        score = 10000;
        scoreEl.innerText = score;
        updateLevel();
        playSound('powerup');
        floatingTexts.push({ x: player.x, y: player.y - 60, text: "DEBUG: SCORE 10000 + CROWN", life: 120, dy: -0.5 });
        
        // Spawn Crown in front of player
        items.push({ x: player.x + 150, y: player.y - 100, width: 45, height: 45, dx: 0, isCollected: false, animIndex: 0, animTimer: 0, type: 'crown' });
    }

    let statusText = "";
    if (superMode) { superModeTimer--; statusText += "üåüSUPER MODE! "; if (superModeTimer <= 0) superMode = false; }
    // ‚òÖÁéãÂÜ†„Éú„Éº„Éä„ÇπÂá¶ÁêÜ
    if (crownBonusMode) { 
        crownBonusTimer--; 
        statusText += "üëëBONUS x3 "; 
        if (crownBonusTimer <= 0) crownBonusMode = false; 
    }
    if (slowMode) { slowModeTimer--; statusText += "üê¢SLOW... "; if (slowModeTimer <= 0) slowMode = false; }
    statusMsgEl.innerText = statusText;
    
    // ÊñáÂ≠óËâ≤„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç
    if (superMode) statusMsgEl.style.color = "gold"; 
    else if (crownBonusMode) statusMsgEl.style.color = "orange";
    else if (slowMode) statusMsgEl.style.color = "violet"; 
    else statusMsgEl.innerText = "";

    let currentSpeed = player.speed;
    if (slowMode) currentSpeed *= 0.5;

    if (player.state !== 'dead') {
        if (player.state !== 'squat') {
            if (keys.right) player.dx = currentSpeed; else if (keys.left) player.dx = -currentSpeed; else player.dx *= FRICTION;
        } else { player.dx *= FRICTION; }
        let nextX = player.x + player.dx; let checkX = player.dx > 0 ? nextX + player.width : nextX;
        let nextGroundY = getGroundYAtX(checkX); 
        if (nextGroundY !== null) { if (player.y + player.height > nextGroundY + 5) player.dx = 0; }
        // ‚òÖ‰øÆÊ≠£: „Ç´„É°„É©‰ΩçÁΩÆ„Åß„ÅÆÂ∑¶Á´ØÂà∂Èôê
        if (nextX < cameraX) { nextX = cameraX; player.dx = 0; }
    }

    player.x += player.dx; player.y += player.dy; player.dy += GRAVITY;
     
    // ‚òÖ‰øÆÊ≠£: „Ç´„É°„É©ËøΩÂæìË®àÁÆó („Éó„É¨„Ç§„É§„Éº‰∏≠ÂøÉ„Å´)
    let targetCameraX = player.x - canvas.width / 2 + player.width / 2;
    if (targetCameraX < 0) targetCameraX = 0;
    if (targetCameraX > cameraX) cameraX = targetCameraX;
     
    updateTerrain();
    const groundY = getGroundYUnderPlayer();
    if (groundY !== null) { 
        if (player.y + player.height >= groundY && player.dy >= 0) { player.y = groundY - player.height; player.dy = 0; player.jumping = false; player.combo = 0; player.jumpCount = 0; } 
    } else { 
        if (player.y > canvas.height) { if (isNaN(player.y)) player.y = 0; if (!gameOver) { hp = 0; updateHearts(); playSound('hit'); handleGameOver(); } } 
    }
     
    updatePlayerAnimation();
    if (gameOver) return;

    updateAndDrawParticles();
    for (let i = 0; i < floatingTexts.length; i++) { let ft = floatingTexts[i]; ft.y += ft.dy; ft.life--; if (ft.life <= 0) { floatingTexts.splice(i, 1); i--; } }

    let playerHitH = player.height; let playerHitY = player.y;
    if (player.state === 'squat') { playerHitH = player.height / 2; playerHitY = player.y + player.height / 2; }

    for (let i = 0; i < items.length; i++) { 
        let item = items[i]; 
        if (item.x + item.width < cameraX - 100) { items.splice(i, 1); i--; continue; }
        
        // ‚òÖÁéãÂÜ†„ÅÆ„Åµ„Çè„Åµ„ÇèÂãï‰Ωú (YÂ∫ßÊ®ô„ÇíSinÊ≥¢„ÅßÊè∫„Çâ„Åô)
        if (item.type === 'crown' && !item.isCollected) {
            item.y += Math.sin(frameCount * 0.1) * 2;
        }

        if (item.isCollected) {
            if (item.type === 'coin') { item.animTimer++; if (item.animTimer > 5) { item.animIndex++; item.animTimer = 0; } if (item.animIndex >= 3) { items.splice(i, 1); i--; } } 
            else { item.animTimer++; if (item.animTimer > 30) { items.splice(i, 1); i--; } }
        } else {
            item.x += item.dx;
            if (item.x + item.width < cameraX - 100) { items.splice(i, 1); i--; continue; } 
            if (player.x < item.x + item.width && player.x + player.width > item.x && playerHitY < item.y + item.height && playerHitY + playerHitH > item.y) {
                item.isCollected = true; item.animIndex = 0; item.animTimer = 0;
                if (item.type === 'coin') { score += 50; playSound('coin'); spawnParticles(item.x, item.y, 'gold', 5); } 
                else if (item.type === 'heal') { hp = 3; updateHearts(); playSound('heal'); spawnParticles(item.x, item.y, 'pink', 8); } 
                else if (item.type === 'star') { superMode = true; superModeTimer = 900; isInvincible = true; invincibleTimer = 900; slowMode = false; slowModeTimer = 0; playSound('powerup'); spawnParticles(item.x, item.y, 'yellow', 10); } 
                else if (item.type === 'trap') { if (!superMode) { slowMode = true; slowModeTimer = 600; playSound('bad'); spawnParticles(item.x, item.y, 'purple', 8); } }
                // ‚òÖÁéãÂÜ†ÂèñÂæóÊôÇ„ÅÆÂäπÊûú
                else if (item.type === 'crown') {
                    crownBonusMode = true; crownBonusTimer = 1800; // 30Áßí
                    playSound('powerup');
                    spawnParticles(item.x, item.y, 'orange', 10);
                    floatingTexts.push({ x: player.x, y: player.y - 40, text: "BONUS x3", life: 90, dy: -0.5 });
                }
                scoreEl.innerText = score; updateLevel(); 
            }
        }
    }

    let stompedThisFrame = false; 
    for (let i = 0; i < enemies.length; i++) { 
        let e = enemies[i]; 
        if (e.x + e.width < cameraX - 100) { enemies.splice(i, 1); i--; continue; }
        e.x += e.dx;
        e.animTimer++; if (e.animTimer > 10) { e.animIndex = (e.animIndex + 1) % 2; e.animTimer = 0; }
        if (e.type === 'flying') { e.angle += 0.1; e.y += Math.sin(e.angle) * 2; } 

        if (player.x < e.x + e.width && player.x + player.width > e.x && playerHitY < e.y + e.height && playerHitY + playerHitH > e.y) { 
            const isStomp = (player.dy > 0 && player.y + player.height < e.y + e.height * 0.6) || stompedThisFrame || superMode;
            if (isStomp) { 
                enemies.splice(i, 1); i--; 
                if (!superMode) { player.dy = -10; stompedThisFrame = true; }
                player.combo++; let multiplier = Math.pow(2, player.combo - 1); let bonusPoints = 100 * multiplier;
                
                // ‚òÖÁéãÂÜ†„Éú„Éº„Éä„ÇπÂäπÊûúÈÅ©Áî®
                if (crownBonusMode) {
                    bonusPoints *= 3;
                    floatingTexts.push({ x: player.x, y: player.y - 40, text: "CROWN BONUS", life: 60, dy: -1.0 });
                }

                score += bonusPoints; scoreEl.innerText = score; playSound('coin'); updateLevel(); 
                if (multiplier > 1) { floatingTexts.push({ x: player.x, y: player.y - 20, text: "BONUS x" + multiplier, life: 60, dy: -1.5 }); }
                spawnParticles(e.x, e.y, 'red', 8);
            } else { 
                if (!isInvincible) { 
                    hp--; if (hp < 0) hp = 0; updateHearts(); playSound('hit'); addShake(15, 20);
                    if (hp <= 0) handleGameOver(); else { isInvincible = true; invincibleTimer = 60; enemies.splice(i, 1); i--; } 
                } 
            } 
        } 
    }

    for (let cp of checkpoints) {
        if (!cp.passed && player.x > cp.x) {
            cp.passed = true; score += 1500; scoreEl.innerText = score; playSound('gate');
            spawnParticles(player.x, player.y, 'cyan', 15);
            floatingTexts.push({ x: player.x, y: player.y - 40, text: "CHECKPOINT! +1500", life: 90, dy: -0.5 });
        }
    }
  }

  function drawParallaxLayer(imgWrapper, scrollFactor, y) {
      if (!imgWrapper || !imgWrapper.ready) return;
      const img = imgWrapper.img; const w = img.width;
      let x = -(cameraX * scrollFactor) % w; if (x > 0) x -= w;
      while (x < canvas.width) { ctx.drawImage(img, x, y); x += w; }
  }

  function drawObj(wrapper, x, y, w, h, fallbackColor) {
    if (wrapper && wrapper.ready && wrapper.img) ctx.drawImage(wrapper.img, x, y, w, h);
    else { ctx.fillStyle = fallbackColor; ctx.fillRect(x, y, w, h); }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let skyColor; if (score < 1000) skyColor = '#B0E0E6'; else if (score < 3000) skyColor = '#FFDAB9'; else if (score < 5000) skyColor = '#483D8B'; else skyColor = '#6A5ACD'; 
    ctx.fillStyle = skyColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
     
    ctx.save(); ctx.translate(screenShake.x, screenShake.y);
    drawParallaxLayer(mountainImgWrapper, 0.1, canvas.height - 250); 
    for(let c of clouds) {
        let wrapper = cloudImgWrappers[c.imgIndex]; let parallaxX = c.x - cameraX * 0.2; 
        if (wrapper && wrapper.ready && wrapper.img) ctx.drawImage(wrapper.img, parallaxX, c.y); 
        else { ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; ctx.beginPath(); ctx.arc(parallaxX, c.y, 30, 0, Math.PI*2); ctx.fill(); }
    }
    drawParallaxLayer(buildingImgWrapper, 0.4, canvas.height - 220); 

    ctx.translate(-cameraX, 0); 
    for (let seg of terrainSegments) { ctx.fillStyle = '#654321'; ctx.fillRect(seg.x, seg.topY, seg.width, canvas.height - seg.topY); ctx.fillStyle = '#228B22'; ctx.fillRect(seg.x, seg.topY, seg.width, 10); }
    ctx.fillStyle = '#999'; ctx.strokeStyle = '#555'; for (let p of platforms) { ctx.fillRect(p.x, p.y, p.width, p.height); ctx.strokeRect(p.x, p.y, p.width, p.height); }
    ctx.strokeStyle = 'yellow'; ctx.lineWidth = 5;
    for (let cp of checkpoints) {
        ctx.beginPath(); ctx.moveTo(cp.x, BASE_GROUND_Y); ctx.lineTo(cp.x, BASE_GROUND_Y - 150); ctx.arc(cp.x + 40, BASE_GROUND_Y - 150, 40, Math.PI, 0); ctx.lineTo(cp.x + 80, BASE_GROUND_Y); ctx.stroke();
        if (!cp.passed) { ctx.fillStyle = 'rgba(0, 255, 255, 0.3)'; ctx.fill(); }
    }

    for (let item of items) {
        if (item.isCollected) {
            if (item.type === 'coin') { let effectWrapper = itemEffectAnim[item.animIndex]; if(effectWrapper) drawObj(effectWrapper, item.x, item.y, item.width, item.height, 'yellow'); }
            else {
                ctx.save(); if (Math.floor(Date.now() / 50) % 2 === 0) ctx.globalAlpha = 0.2; else ctx.globalAlpha = 0.8;
                if (item.type === 'heal') drawObj(capsuleImgWrapper, item.x, item.y, item.width, item.height, 'pink'); 
                else if (item.type === 'star') drawObj(mutekiImgWrapper, item.x, item.y, item.width, item.height, 'yellow'); 
                else if (item.type === 'trap') drawObj(jyamaImgWrapper, item.x, item.y, item.width, item.height, 'purple');
                // ‚òÖÁéãÂÜ†„ÅÆ„Ç®„Éï„Çß„ÇØ„Éà
                else if (item.type === 'crown') drawObj(crownImgWrapper, item.x, item.y, item.width, item.height, 'orange');
                ctx.restore();
            }
        } else {
            if (item.type === 'coin') drawObj(itemImgWrapper, item.x, item.y, item.width, item.height, 'gold'); 
            else if (item.type === 'heal') drawObj(capsuleImgWrapper, item.x, item.y, item.width, item.height, 'pink'); 
            else if (item.type === 'star') drawObj(mutekiImgWrapper, item.x, item.y, item.width, item.height, 'yellow'); 
            else if (item.type === 'trap') drawObj(jyamaImgWrapper, item.x, item.y, item.width, item.height, 'purple');
            // ‚òÖÁéãÂÜ†„ÅÆÊèèÁîª
            else if (item.type === 'crown') drawObj(crownImgWrapper, item.x, item.y, item.width, item.height, 'orange');
        }
    }

    for (let e of enemies) { 
        let animWrapper = null; if (e.type === 'hard') { animWrapper = enemy2Anim[e.animIndex] || enemy2Anim[0]; drawObj(animWrapper, e.x, e.y, e.width, e.height, 'purple'); } else { animWrapper = enemyAnim[e.animIndex] || enemyAnim[0]; drawObj(animWrapper, e.x, e.y, e.width, e.height, 'red'); }
    }

    ctx.save();
    if (superMode) { if (Math.floor(Date.now() / 50) % 2 === 0) { ctx.globalAlpha = 0.8; ctx.filter = 'brightness(1.5) drop-shadow(0 0 5px gold)'; } } 
    // ‚òÖÁéãÂÜ†„Éú„Éº„Éä„Çπ‰∏≠„ÅÆ„Éó„É¨„Ç§„É§„Éº„Ç®„Éï„Çß„ÇØ„Éà
    else if (crownBonusMode) { if (Math.floor(Date.now() / 50) % 2 === 0) { ctx.filter = 'drop-shadow(0 0 5px orange)'; } }
    else if (slowMode) { ctx.filter = 'hue-rotate(270deg)'; } 
    else if (isInvincible) { if (Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.5; }
     
    let currentWrapper = null;
    if (player.state === 'dead') currentWrapper = playerAnim.dead; else if (player.state === 'squat') currentWrapper = playerAnim.squat; else if (playerAnim[player.state] && playerAnim[player.state][player.animIndex]) currentWrapper = playerAnim[player.state][player.animIndex];

    if (!isNaN(player.x) && !isNaN(player.y)) {
        if (!facingRight) { ctx.translate(player.x + player.width, player.y); ctx.scale(-1, 1); drawObj(currentWrapper, 0, 0, player.width, player.height, 'blue'); } else { drawObj(currentWrapper, player.x, player.y, player.width, player.height, 'blue'); }
    }
    ctx.restore();

    for(let p of particles) { ctx.fillStyle = p.color; ctx.globalAlpha = Math.min(p.life / 20, 1.0); ctx.fillRect(p.x, p.y, p.size, p.size); ctx.globalAlpha = 1.0; }
    ctx.fillStyle = "yellow"; ctx.font = "bold 20px Courier New"; ctx.strokeStyle = "black"; ctx.lineWidth = 3;
    for (let ft of floatingTexts) { ctx.strokeText(ft.text, ft.x, ft.y); ctx.fillText(ft.text, ft.x, ft.y); }
    ctx.restore();
  }

  function loop() { if (!isPaused) update(); draw(); requestAnimationFrame(loop); }

  resetGame(); loop(); 
</script>
</body>
</html>
